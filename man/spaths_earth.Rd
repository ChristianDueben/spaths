% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spaths_earth.R
\name{spaths_earth}
\alias{spaths_earth}
\title{Shortest Paths between Geographic Locations on Earth}
\usage{
spaths_earth(
  rst,
  origins,
  destinations = NULL,
  output = c("lines", "distances"),
  origin_names = NULL,
  destination_names = NULL,
  pairwise = FALSE,
  contiguity = c("queen", "rook"),
  dist_comp = c("spaths", "terra"),
  tr_fun = NULL,
  v_matrix = FALSE,
  tr_directed = TRUE,
  update_rst = NULL,
  touches = TRUE,
  copy = TRUE,
  round_dist = FALSE,
  ncores = NULL,
  par_lvl = c("points", "points_lists", "update_rst"),
  rst_par_lvl = c("points", "points_lists", "none"),
  cluster = NULL,
  paths_ncores = NULL,
  verbose = FALSE
)
}
\arguments{
\item{rst}{SpatRaster (terra) or RasterLayer (raster) object. RasterLayers are converted to SpatRasters. Pixels with non-NA values in all layers mark 
the cells through which the algorithm may pass.}

\item{origins}{A single SpatVector (terra), sf (sf), or Spatial* (sp) object, or a list of them. Non-SpatVectors are converted to SpatVectors. 
Polygons and lines are converted to points using their centroid. Passing a list of spatial objects is a way not to relate all origins to all 
destinations. Details are outlined below.}

\item{destinations}{A single SpatVector (terra), sf (sf), or Spatial* (sp) object, a list of them, or \code{NULL}. It defaults to \code{NULL}, 
resulting in the function to compute shortest paths between the \code{origins} points. Non-SpatVectors are converted to SpatVectors. Polygons and 
lines are converted to points using their centroid. Passing a list of spatial objects is a way not to relate all origins to all destinations. Details 
are outlined below.}

\item{output}{\code{"lines"} (default) or \code{"distances"}. \code{"lines"} returns the shortest paths as SpatVector lines. \code{"distances"} lists 
the total transition costs along the shortest paths. By default, it is the distance between origin and destination in meters. If you pass another 
function to \code{tr_fun}, the total transition cost is measured in the units of \code{tr_fun}'s results. \code{"distances"} is faster and requires 
less RAM than \code{"lines"}.}

\item{origin_names}{Character specifying the name of the column in the \code{origins} object used to label the origins in the output object. It 
defaults to row numbers, which are more efficient than character labels.}

\item{destination_names}{Character specifying the name of the column in the \code{destinations} object used to label the origins in the output object. 
It defaults to row numbers, which are more efficient than character labels.}

\item{pairwise}{Logical specifying whether to compute pairwise paths, if \code{origins} and \code{destinations} have equally many rows. If \code{TRUE}, 
the function computes the shortest path between the first origin and the first destination, the second origin and the second destination etc. 
Otherwise, it derives the shortest paths from all origins to all destinations.}

\item{contiguity}{"queen" (default) for queen's case contiguity or "rook" for rook's case contiguity. In the latter case, the algorithm is only 
allowed to move between horizontally or vertically adjacent cells. In the former case, it is also allowed to travel between diagonally adjacent cells. 
"rook" is more efficient than "queen" as it implies fewer edges.}

\item{dist_comp}{\code{"spaths"} (default) or \code{"terra"}. The former uses spherical (Haversine) distances in case of lonlat data and planar 
(Euclidean) distances in case of projected (non-lonlat) data. The functions are optimized based on the fact that many inter-pixel distances are 
identical. Modelling the planet as a perfect sphere is in line with e.g. the s2 package, but is of course an oversimplification. With \code{"terra"}, 
the function derives distances via \code{terra::distance}. Because this computes all inter-pixel distances separately, it is slower than the 
\code{"spaths"} approach. It does take the non-spherical nature of the planet into account though. And as there is no guarantee that the \code{"spaths"} 
Euclidean function get the distances right in case of all projections, \code{"terra"} is the safer option for non-lonlat data.}

\item{tr_fun}{The transition function based on which to compute edge weights, i.e. the travel cost between grid cells. Defaults to the geographic 
distance between pixel centroids. Permitted function parameter names are \code{d} (distance between the pixel centroids), \code{x1} (x coordinate or 
longitude of the first cell), \code{x2} (x coordinate or longitude of the second cell), \code{y1} (y coordinate or latitude of the first cell), 
\code{y2} (y coordinate or latitude of the second cell), \code{v1} (\code{rst} layers' values from the first cell), \code{v2} (\code{rst} layers' 
values from the second cell), \code{nc} (number of CPU cores), and \code{cl} (cluster object returned by \code{parallel::makePSOCKcluster(ncores)} or 
\code{parallel::makeForkCluster(ncores)}). If \code{lonlat} is \code{TRUE} or if \code{dist_comp = "terra"}, \code{d} is measured in the meters. 
Otherwise, it uses the units of the CRS. \code{nc} is meant to be used in C++ functions. A parallel backend at the R level pointed to by \code{cl} is 
already registered before \code{tr_fun} is called, in case \code{ncores > 1}. If \code{rst} has one layer, the values are passed to \code{v1} and 
\code{v2} as vectors, otherwise they are passed as a data table where the first column refers to the first layer, the second column to the second 
layer etc. Note that data tables are also data frames.}

\item{v_matrix}{Logical specifying whether to pass values to \code{v1} and \code{v2} in \code{tr_fun} as matrices (\code{TRUE}) instead of data tables 
in the multi-layer case and vectors in the single-layer case (\code{FALSE}). It defaults to \code{FALSE}. Setting it to \code{TRUE} might e.g. be 
useful when defining \code{tr_fun} as a C++ Armadillo function.}

\item{tr_directed}{Logical specifying whether \code{tr_fun} creates a directed graph. In a directed graph, transition costs can be asymmetric. 
Traveling from cells A to B may imply a different cost than traveling from B to A. It defaults to \code{TRUE} and only has an effect when 
\code{tr_fun} is not \code{NULL}. The default without \code{tr_fun} constructs an undirected graph.}

\item{update_rst}{A single SpatVector (terra), sf (sf), or Spatial* (sp) object, a list of them, or \code{NULL}. It defaults to \code{NULL}, 
corresponding to \code{rst} not being updated. sf and sp objects are converted to SpatVectors. If \code{update_rst} is a single vector object, the 
shortest paths are computed twice. The function first derives the paths based on the specified \code{rst}, then removes all cells intersecting with 
the vector object, and derives the paths based on the updated set of cells. The result is a list of length two, where the first element entails the 
paths from the unmodified \code{rst} and the second element the paths from the updated \code{rst}. If \code{update_rst} is a list, the function 
produces a list that is one element longer than \code{update_rst} is. The first element again consists of shortest paths based on the unupdated 
\code{rst}, while the subsequent elements accomodate paths derived from the updated \code{rst}s. The updates always start from the original \code{rst}. 
I.e. \code{update_rst[[2]]} does not modify the \code{rst} updated by \code{update_rst[[1]]}, but the \code{rst} unadjusted by any element of 
\code{update_rst}. Note that \code{update_rst} only removes cells. Any pixels with NA values in the original \code{rst} remain excluded from the set 
of transition cells. Neither does \code{update_rst} alter cell values from any of \code{rst}'s layers.}

\item{touches}{Logical specifying the \code{touches} argument of \code{terra::extract} used when \code{update_rst} is not \code{NULL}. It defaults to 
\code{TRUE}. If \code{FALSE}, the function only removes cells on the line render path or with the center point inside a polygon.}

\item{copy}{Logical specifying whether to copy paths that are unaffected by \code{update_rst} geometries (\code{TRUE}) rather than re-estimating all 
paths on the grids updated by \code{update_rst} (\code{FALSE}). It defaults to \code{TRUE} and only has an effect when \code{update_rst} is not 
\code{NULL}. If \code{TRUE}, the function first computes paths on the unmodified \code{rst} and then checks which paths' cells intersect with the 
geometries in \code{update_rst}. If you know that all paths are affected by \code{update_rst}, setting \code{copy} to \code{FALSE} can be the more 
efficient choice. This especially holds in two scenarios: (i) if you use multiple cores and \code{par_lvl = "update_rst"}, \code{copy = FALSE} directly 
parallelizes the function over the different grids, incl. the unmodified \code{rst}, rather than waiting for the paths on the initial grid to be 
computed before parallelizing over the remaining grids; (ii) if \code{output = "distances"}, the function only computes distances when 
\code{copy = FALSE}, but engages in the more time consuming task of returning lines for the first grid when \code{copy = TRUE}. Thus, the function 
tends to be faster with \code{copy = TRUE} than with \code{copy = FALSE}, unless quasi all paths are affected by \code{update_rst}, with both 
\code{output = "lines"} and \code{output = "distances"}.}

\item{round_dist}{Logical specifying whether to round edge weights, i.e. the transition cost or distance between neighboring cells, to integers. It 
defaults to \code{FALSE}. Setting it to \code{TRUE} reduces the function's RAM requirements slightly.}

\item{ncores}{An integer specifying the number of CPU cores to use. It defaults to the number of cores installed on the machine. A value of 1 
accordingly induces a single-threaded process.}

\item{par_lvl}{\code{"points"} (default), \code{"points_lists"}, or \code{"update_rst"}, indicating the level at which to parallelize when using 
multiple cores. \code{"points"} parallelizes over the origin (and destination) point combinations. \code{"points_lists"} parallelizes over the list 
elements of \code{origins} (and \code{destinations}), if these arguments are lists. \code{"update_rst"} parallelizes over the list of graphs specified 
by \code{rst} and \code{update_rst}.}

\item{rst_par_lvl}{\code{"points"} (default), \code{"points_lists"}, or \code{"none"}, indicating the level at which to parallelize the paths 
computations on the unmodified \code{rst} when using multiple cores, \code{update_rst} is not \code{NULL}, \code{par_lvl = "update_rst"}, and 
\code{copy = TRUE}. Because the function requires the paths from the unmodified \code{rst} before looping over the updated grids when 
\code{copy = TRUE}, the parallel structure requested by \code{par_lvl = "update_rst"} only commences after those initial paths have been identified. 
\code{rst_par_lvl} defines the parallel level at which those initial paths are derived. \code{"points"} (default) and \code{"points_list"} are 
equivalent to their counterparts in \code{par_lvl}, \code{"none"} induces a serial, i.e. non-parallel, execution.}

\item{cluster}{\code{"PSOCK"} or \code{"FORK"}, indicating the type of \code{parallel} cluster that the function employs when \code{ncores > 1} or 
\code{paths_ncores > 1}. The function defaults to \code{"PSOCK"} on Windows and to \code{"FORK"} otherwise. Windows machines must use \code{"PSOCK"}, 
while Mac and Linux can employ either of the two options.}

\item{paths_ncores}{An integer specifying the number of CPU cores to use in shortest paths computations. It defaults to the value of \code{ncores}. 
Thus, only set it, if you want edge weights and shortest paths be computed with differently many cores. The \code{dist_comp = "spaths"} edge weight
computations employ efficient C++ level parallelization. The shortest paths sections, in contrast, parallelize on the R level. If you use a \code{PSOCK} 
cluster, \code{spaths_earth} copies various objects to the workers before the paths algorithm is applied. This can make the parallel execution slower 
than its serial counterpart. Thus, consider setting \code{paths_ncores = 1}, especially when working with \code{PSOCK} clusters.}

\item{verbose}{Logical specifying whether the function prints messages on progress. It defaults to \code{FALSE}.}
}
\value{
In the basic cases, i.e. when neither \code{origins} nor \code{destinations} are lists and \code{update_rst} is not specified, the function 
returns a SpatVector lines object with \code{output = "lines"} and a data table with \code{output = "distances"}. If \code{origins} or 
\code{destinations} are lists or \code{update_rst} is specified, it returns a list or nested list of SpatVectors or data tables. In the nested case, 
the outer list refers to the \code{update_rst} level and the inner list to the \code{origins} and \code{destinations} level. Consult the 
\href{../doc/spaths_introduction.html}{vignette} for further details.

The distances are the total transition costs along the shortest paths. If \code{lonlat} is \code{TRUE} or if \code{dist_comp = "terra"}, these 
distances are measured in the meters. Otherwise, they use the units of the CRS. If you pass a function to \code{tr_fun}, the total transition cost is 
measured in the units of \code{tr_fun}'s results.
}
\description{
The function computes the shortest paths between locations on planet Earth using Dijstra's algorithm.
}
\details{
This function computes shortest paths between locations on Earth, taking custom transition costs into account. Examples are a ship navigating 
around land masses or a hiker traversing mountains.

The algorithm links \code{origins} and \code{destinations} by passing through the centroids of \code{rst}'s non-NA cells.

The \href{../doc/spaths_introduction.html}{vignette} provides further details on the function.
}
\examples{
\dontrun{
# Generate example data
set.seed(20146)
rst <- terra::rast(crs = "epsg:4326", resolution = 1L, vals = sample(c(1L, NA), 64800L, TRUE,
  c(0.9, 0.1)))
origins <- rnd_locations(5L, output_type = "terra")
destinations <- rnd_locations(5L, output_type = "terra")

# Compute shortest paths
spaths_earth(rst, origins)
spaths_earth(rst, origins, destinations)
}

}
\seealso{
\link{spaths_general}
}
