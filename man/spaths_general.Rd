% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spaths_general.R
\name{spaths_general}
\alias{spaths_general}
\title{Shortest Paths between Geographic Locations in General}
\usage{
spaths_general(
  rst,
  xres,
  yres,
  xmin,
  ymin,
  origins,
  destinations = NULL,
  lonlat = TRUE,
  radius = NULL,
  output = c("lines", "distances"),
  origin_names = NULL,
  destination_names = NULL,
  pairwise = FALSE,
  contiguity = c("queen", "rook"),
  tr_fun = NULL,
  v_matrix = FALSE,
  tr_directed = TRUE,
  round_dist = FALSE,
  ncores = NULL,
  par_lvl = c("points", "points_lists"),
  cluster = NULL,
  paths_ncores = NULL,
  write_dir = NULL,
  file_type = NULL,
  unconnected_error = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{rst}{Matrix or list of matrices denoting the grid through via the points are connected. Pixels with non-NA values in all matrices mark the cells 
through which the algorithm may pass. A list of matrices is handled as a multi-layered grid, allowing for a cell to have multiple values. Thus, only 
use a list instead of a single matrix, if you are utilizing the cell values, i.e. passing a function with the \code{v1} or \code{v2} parameters to 
\code{tr_fun}.}

\item{xres}{Numeric specifying \code{rst}'s resolution along the x dimension, as in \code{terra::xres}.}

\item{yres}{Numeric specifying \code{rst}'s resolution along the y dimension, as in \code{terra::yres}.}

\item{xmin}{Numeric specifying \code{rst}'s xmin, as in \code{terra::xmin}.}

\item{ymin}{Numeric specifying \code{rst}'s ymin, as in \code{terra::ymin}.}

\item{origins}{A single matrix or data frame, or a list of them. The first column states the x and the second column the y coordinates, irrespective 
of what the column names are.}

\item{destinations}{A single matrix or data frame, a list of them. The first column states the x and the second column the y coordinates, irrespective 
of what the column names are. It defaults to \code{NULL}, resulting in the function to compute shortest paths between the \code{origins} points. 
Passing a list of data frames or matrices is a way not to relate all origins to all destinations. Details are outlined below.}

\item{lonlat}{Logical specifying whether the data is in lonlat (\code{TRUE}), i.e. spherical, or in planar (\code{FALSE}) format. It defaults to 
\code{TRUE}.}

\item{radius}{The radius of the sphere, if \code{lonlat} is \code{TRUE}. It is ignored, if \code{lonlat} is \code{FALSE} of if the function passed to 
\code{tr_fun} does not use the parameter \code{d}.}

\item{output}{\code{"lines"} (default) or \code{"distances"}. \code{"lines"} returns the shortest paths as SpatVector lines. \code{"distances"} lists 
the total transition costs along the shortest paths, which is by default the distance between origin and destination. If \code{lonlat} is \code{TRUE}, 
these distances are measured in the same units as \code{radius}. If \code{lonlat} is \code{FALSE}, the units are the same as those of \code{yres}, 
\code{yres}, \code{xmin}, \code{ymin}, \code{origins}, and \code{destinations}. If you pass a function to \code{tr_fun}, the total transition cost is 
measured in the units of \code{tr_fun}'s results. \code{"distances"} is faster and requires less RAM than \code{"lines"}.}

\item{origin_names}{Character specifying the name of the column in the \code{origins} object used to label the origins in the output object. It 
defaults to row numbers, which are more efficient than character labels.}

\item{destination_names}{Character specifying the name of the column in the \code{destinations} object used to label the origins in the output object. 
It defaults to row numbers, which are more efficient than character labels.}

\item{pairwise}{Logical specifying whether to compute pairwise paths, if \code{origins} and \code{destinations} have equally many rows. If \code{TRUE}, 
the function computes the shortest path between the first origin and the first destination, the second origin and the second destination etc. 
Otherwise, it derives the shortest paths from all origins to all destinations.}

\item{contiguity}{"queen" (default) for queen's case contiguity or "rook" for rook's case contiguity. In the latter case, the algorithm is only 
allowed to move between horizontally or vertically adjacent cells. In the former case, it is also allowed to travel between diagonally adjacent cells. 
"rook" is more efficient than "queen" as it implies fewer edges.}

\item{tr_fun}{The transition function based on which to compute edge weights, i.e. the travel cost between grid cells. Defaults to the geographic 
distance between pixel centroids. Permitted function parameter names are \code{d} (distance between the pixel centroids), \code{x1} (x 
coordinate or longitude of the first cell), \code{x2} (x coordinate or longitude of the second cell), \code{y1} (y coordinate or latitude of the first 
cell), \code{y2} (y coordinate or latitude of the second cell), \code{v1} (\code{rst}'s value from the first cell), \code{v2} (\code{rst}'s 
value from the second cell), \code{nc} (number of CPU cores), and \code{cl} (cluster object returned by \code{parallel::makePSOCKcluster(ncores)} or 
\code{parallel::makeForkCluster(ncores)}). If \code{lonlat} is \code{TRUE}, \code{d} is measured in the same units as \code{radius}. If \code{lonlat} 
is \code{FALSE}, the units are the same as those of \code{yres}, \code{yres}, \code{xmin}, \code{ymin}, \code{origins}, and \code{destinations}. 
\code{nc} is meant to be used in C++ functions. A parallel backend at the R level pointed to by \code{cl} is already registered before \code{tr_fun} 
is called, in case \code{ncores > 1}. If \code{rst} is a single matrix, the values are passed to \code{v1} and \code{v2} as vectors, otherwise they 
are passed as a data table where the first column refers to the first matrix, the second column to the second matrix etc. Note that data tables are 
also data frames.}

\item{v_matrix}{Logical specifying whether to pass values to \code{v1} and \code{v2} in \code{tr_fun} as matrices (\code{TRUE}) instead of data tables 
in the list case and vectors in the single matrix case (\code{FALSE}). It defaults to \code{FALSE}. Setting it to \code{TRUE} might e.g. be useful when 
defining \code{tr_fun} as a C++ Armadillo function.}

\item{tr_directed}{Logical specifying whether \code{tr_fun} creates a directed graph. In a directed graph, transition costs can be asymmetric. 
Traveling from cell A to cell B may imply a different cost than traveling from B to A. It defaults to \code{TRUE} and only has an effect when 
\code{tr_fun} is not \code{NULL}. The default without \code{tr_fun} constructs an undirected graph.}

\item{round_dist}{Logical specifying whether to round edge weights, i.e. the transition cost between neighboring cells, to integers. It defaults to 
\code{FALSE}. Setting it to \code{TRUE} reduces the function's RAM requirements slightly.}

\item{ncores}{An integer specifying the number of CPU cores to use. It defaults to the number of cores installed on the machine. A value of 1 
accordingly induces a single-threaded process.}

\item{par_lvl}{\code{"points"} (default) or \code{"points_lists"}, indicating the level at which to parallelize when \code{ncores > 1}. \code{"points"} 
parallelizes over the origin (and destination) point combinations. \code{"points_lists"} parallelizes over the list elements of \code{origins} (and 
\code{destinations}), if these arguments are lists.}

\item{cluster}{\code{"PSOCK"}, \code{"FORK"}, or \code{"MPI"}, indicating the type of \code{parallel} cluster that the function employs when 
\code{ncores > 1} or \code{paths_ncores > 1}. The function defaults to \code{"PSOCK"} on Windows and to \code{"FORK"} otherwise. \code{"FORK"} is not 
available on Windows machines. \code{"MPI"} requires the Rmpi and snow packages to be installed. There are various ways of parallelizing R with MPI. 
This function utilizes the variant implemented in the snow package.}

\item{paths_ncores}{An integer specifying the number of CPU cores to use in shortest paths computations. It defaults to the value of \code{ncores}. 
Thus, only set it, if you want edge weights and shortest paths be computed with differently many cores. The \code{dist_comp = "spaths"} edge weight
computations employ efficient C++ level parallelization. The shortest paths sections, in contrast, parallelize on the R level. If you use a \code{PSOCK} 
cluster, \code{spaths_earth} copies various objects to the workers before the paths algorithm is applied. This can make the parallel execution slower 
than its serial counterpart. Thus, consider setting \code{paths_ncores = 1}, especially when working with \code{PSOCK} clusters.}

\item{write_dir}{Directory to which write output. If \code{NULL} (default), the output is not written to disk but returned by the function. When 
specifying a directory, \code{spaths_general} writes the output to it and returns \code{NULL}. Keeping the results in RAM is commonly faster than 
writing them to disk. Thus, the recommendation is to keep the default unless your machine has insufficient RAM. In cases in which the function would 
return a list, i.e. if \code{origins} or \code{destinations} are lists, \code{spaths_general} writes one file per list element. File names state which 
element the file represents: the number following \code{p} points to the element of \code{origins} or \code{destinations}. Values begin at 1. In 
generating file names of equal length, the function employs leading zeros. So, if the function computes 100 SpatVectors, the file corresponding to the 
first list element is not \code{p1} but \code{p001}. In the basic case, in which the result is a single data.table or SpatVector object, the output 
file is named \code{results}. The directory must not contain any file named as one of the output files - irrespective of file type - if 
\code{output = "lines"}.}

\item{file_type}{The output file type when \code{write_dir} is specified. It defaults to \code{"shp"} in case \code{output = "lines"}, but can also 
be set to \code{"kml"}, \code{"json"}, or any other vector format that \code{terra::writeVector} can write. \code{terra::gdal(drivers = TRUE)} lists 
drivers. \code{output = "distances"} defaults to \code{"rds"} as file type, but can alternatively be set to \code{"csv"}.}

\item{unconnected_error}{Logical specifying whether the function throws an error when trying to compute the distance between locations unconnected by 
the \code{rst} grid. If \code{TRUE} (default), the function throws and error and aborts. If \code{FALSE}, unconnected places have an \code{Inf} 
distance. If \code{output = "lines"}, attempting to link unconnected places always throws an error.}

\item{verbose}{Logical specifying whether the function prints messages on progress. It defaults to \code{FALSE}.}
}
\value{
In the basic cases, i.e. when neither \code{origins} nor \code{destinations} are lists, the function returns a SpatVector lines object with 
\code{output = "lines"} and a data table with \code{output = "distances"}. If \code{origins} or \code{destinations} are lists, it returns a list of 
SpatVectors or data tables. Consult the \href{../doc/spaths_introduction.html}{vignette} for further details.

The distances are the total transition costs along the shortest paths. If \code{lonlat} is \code{TRUE}, these distances are measured in the same units 
as \code{radius}. If \code{lonlat} is \code{FALSE}, the units are the same as those of \code{yres}, \code{yres}, \code{xmin}, \code{ymin}, 
\code{origins}, and \code{destinations}. If you pass a function to \code{tr_fun}, the total transition cost is measured in the units of \code{tr_fun}'s 
results.
}
\description{
The function computes the shortest paths between locations in general using Dijstra's algorithm. While \code{spaths_earth} derives shortest paths between 
locations on Earth, this function deduces them on any sphere or plane.
}
\details{
This function computes shortest paths between points on a sphere or a plane, taking custom transition costs into account. The sphere could be 
the moon or an orange. The plane could be the projected surface of a planet or a table top. The function computes shortest paths, irrespective of 
whether it represents a rover navigating the Marsian topography or an ant traveling between a coffee mug and a laptop on your desk.

The algorithm links \code{origins} and \code{destinations} by passing through the centroids of \code{rst}'s non-NA cells.

The \href{../doc/spaths_introduction.html}{vignette} provides further details on the function.
}
\examples{
\dontrun{
# Generate example data
set.seed(20146)
rst <- matrix(sample(c(1L, NA), 64800L, TRUE, c(0.9, 0.1)), 180L, 360L)
origins <- rnd_locations(5L)
destinations <- rnd_locations(5L)

# Compute shortest paths
spaths_general(rst, 1, 1, -180, -90, origins, radius = 6000)
spaths_general(rst, 1, 1, -180, -90, origins, destinations, radius = 6000)
}

}
\seealso{
\link{spaths_earth}
}
